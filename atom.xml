<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LichFaker的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lichfaker.com/"/>
  <updated>2018-08-26T05:43:44.397Z</updated>
  <id>http://blog.lichfaker.com/</id>
  
  <author>
    <name>LichFaker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>邮件设置</title>
    <link href="http://blog.lichfaker.com/2018/08/24/Mac%20Mail%E9%82%AE%E4%BB%B6%E8%AE%BE%E7%BD%AE/"/>
    <id>http://blog.lichfaker.com/2018/08/24/Mac Mail邮件设置/</id>
    <published>2018-08-24T10:38:32.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-按规则整理邮箱"><a href="#1-按规则整理邮箱" class="headerlink" title="1. 按规则整理邮箱"></a>1. 按规则整理邮箱</h3><p>在Preferences-Rules中添加规则</p><p><img src="../images/mail-aliyun.jpeg" alt=""></p><h3 id="2-设置图片以附件形式发送"><a href="#2-设置图片以附件形式发送" class="headerlink" title="2. 设置图片以附件形式发送"></a>2. 设置图片以附件形式发送</h3><p>终端执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.mail DisableInlineAttachmentViewing 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-按规则整理邮箱&quot;&gt;&lt;a href=&quot;#1-按规则整理邮箱&quot; class=&quot;headerlink&quot; title=&quot;1. 按规则整理邮箱&quot;&gt;&lt;/a&gt;1. 按规则整理邮箱&lt;/h3&gt;&lt;p&gt;在Preferences-Rules中添加规则&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
      <category term="tips" scheme="http://blog.lichfaker.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant shared folder</title>
    <link href="http://blog.lichfaker.com/2018/05/24/Vagrant%20shared%20folder/"/>
    <id>http://blog.lichfaker.com/2018/05/24/Vagrant shared folder/</id>
    <published>2018-05-24T14:00:58.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vagrant was unable to mount VirtualBox shared folders. This is usually</span><br><span class="line">because the filesystem &quot;vboxsf&quot; is not available. This filesystem is</span><br><span class="line">made available via the VirtualBox Guest Additions and kernel module.</span><br><span class="line">Please verify that these guest additions are properly installed in the</span><br><span class="line">guest. This is not a bug in Vagrant and is usually caused by a faulty</span><br><span class="line">Vagrant box. For context, the command attempted was:</span><br><span class="line"></span><br><span class="line">mount -t vboxsf -o uid=1000,gid=1000 vagrant_data /vagrant_data</span><br><span class="line"></span><br><span class="line">The error output from the command was:</span><br><span class="line"></span><br><span class="line">/sbin/mount.vboxsf: mounting failed with the error: No such device</span><br></pre></td></tr></table></figure><p>View the log at <code>/var/log/vboxadd-install.log</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: unable to find the sources of your current Linux kernel.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Useless-solutions"><a href="#Useless-solutions" class="headerlink" title="Useless solutions"></a>Useless solutions</h3><ol><li><p>upgrade or reinstall Linux kernel</p><p> sudo yum install gcc kernel-devel kernel-headers</p><p> Loaded plugins: fastestmirror<br> Loading mirror speeds from cached hostfile</p><ul><li>base: mirrors.163.com</li><li>extras: mirrors.163.com</li><li>updates: mirrors.163.com<br>Package gcc-4.8.5-28.el7_5.1.x86_64 already installed and latest version<br>Package kernel-devel-3.10.0-862.3.2.el7.x86_64 already installed and latest version<br>Package kernel-headers-3.10.0-862.3.2.el7.x86_64 already installed and latest version<br>Nothing to do</li></ul></li></ol><ol start="2"><li><p>upgrade &amp;&amp; downgrade virtualbox</p></li><li><p>reinstall vagrant</p></li></ol><h3 id="Final-solution"><a href="#Final-solution" class="headerlink" title="Final solution"></a>Final solution</h3><ol><li><p>just remove the directory <code>~/.vagrant.d</code></p></li><li><p>vagrant reload</p></li></ol><p>My environment：</p><ul><li>Vagrant 2.1.1</li><li>Virtualbox 5.1.36</li><li>OSX 10.13.2</li></ul><h2 id="vagrant-up-crashes-with-vboxsf"><a href="#vagrant-up-crashes-with-vboxsf" class="headerlink" title="vagrant up crashes with vboxsf"></a>vagrant up crashes with vboxsf</h2><p>Vagrant was unable to mount VirtualBox shared folders. This is usually<br>because the filesystem “vboxsf” is not available. This filesystem is<br>made available via the VirtualBox Guest Additions and kernel module.<br>Please verify that these guest additions are properly installed in the<br>guest. This is not a bug in Vagrant and is usually caused by a faulty<br>Vagrant box. For context, the command attempted was:</p><p>mount -t vboxsf -o uid=1000,gid=1000 home_vagrant_labs /home/vagrant/labs</p><p>The error output from the command was:</p><p>mount: unknown filesystem type ‘vboxsf’</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>vagrant plugin install vagrant-vbguest</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Vagrant was unable to mount VirtualBox shared folders. This is usually&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;because the filesystem &amp;quot;vboxsf&amp;quot; is not available. This filesystem is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;made available via the VirtualBox Guest Additions and kernel module.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please verify that these guest additions are properly installed in the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;guest. This is not a bug in Vagrant and is usually caused by a faulty&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vagrant box. For context, the command attempted was:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mount -t vboxsf -o uid=1000,gid=1000 vagrant_data /vagrant_data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The error output from the command was:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/sbin/mount.vboxsf: mounting failed with the error: No such device&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;View the log at &lt;code&gt;/var/log/vboxadd-install.log&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error: unable to find the sources of your current Linux kernel.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://blog.lichfaker.com/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Docker去sudo</title>
    <link href="http://blog.lichfaker.com/2018/05/03/Docker%E5%8E%BBsudo/"/>
    <id>http://blog.lichfaker.com/2018/05/03/Docker去sudo/</id>
    <published>2018-05-03T09:45:32.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>linux</code>上每次执行<code>docker</code>命令，都得加<code>sudo</code>权限。为方便使用，将普通用户加入<code>docker用户组</code>即可解决上述问题。</p><p>操作：</p><ol><li><p>查看创建用户组：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br></pre></td></tr></table></figure><p> 如果不存在该用户组，则创建：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></li><li><p>添加用户到用户组</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure></li><li><p>修改权限。 若不执行则会： <code>connect: permission denied</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure></li><li><p>重启 <code>docker</code> 服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;linux&lt;/code&gt;上每次执行&lt;code&gt;docker&lt;/code&gt;命令，都得加&lt;code&gt;sudo&lt;/code&gt;权限。为方便使用，将普通用户加入&lt;code&gt;docker用户组&lt;/code&gt;即可解决上述问题。&lt;/p&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="tips" scheme="http://blog.lichfaker.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Golang规范</title>
    <link href="http://blog.lichfaker.com/2018/04/04/Golang%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lichfaker.com/2018/04/04/Golang规范/</id>
    <published>2018-04-04T16:39:26.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-命名"><a href="#1-命名" class="headerlink" title="1. 命名"></a>1. 命名</h2><h3 id="1-1-文件命名"><a href="#1-1-文件命名" class="headerlink" title="1.1 文件命名"></a>1.1 文件命名</h3><p>文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。<br>其中测试文件以<code>_test.go</code>结尾，除测试文件外，命名不出现<code>_</code>。</p><p>例子：<code>stringutil.go</code>， <code>stringutil_test.go</code></p><h3 id="1-2-package"><a href="#1-2-package" class="headerlink" title="1.2 package"></a>1.2 package</h3><p>包名用小写,使用短命名,尽量和标准库不要冲突。<br>包名统一使用单数形式。</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如DNS）的时候，特有名词根据是否私有全部大写或小写。</p><p>例子： <code>apiClient</code>、<code>URLString</code></p><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>同变量规则，力求语义表达完整清楚，不要嫌名字长。<br>如果模块复杂，为避免混淆，可按功能统一定义在<code>package</code>下的一个文件中。</p><h3 id="1-5-接口"><a href="#1-5-接口" class="headerlink" title="1.5 接口"></a>1.5 接口</h3><p>单个函数的接口名以 <code>er</code> 为后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数的接口名综合两个函数名，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type WriteFlusher interface &#123;</span><br><span class="line">    Write([]byte) (int, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个以上函数的接口名类似于结构体名，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Car interface &#123;</span><br><span class="line">    Start() </span><br><span class="line">    Stop()</span><br><span class="line">    Drive()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-6-结构体"><a href="#1-6-结构体" class="headerlink" title="1.6 结构体"></a>1.6 结构体</h3><p>结构体名应该是名词或名词短语，如<code>Account</code>,<code>Book</code>，避免使用<code>Manager</code>这样的。<br>如果该数据结构需要序列化，如<code>json</code>， 则首字母大写， 包括里面的字段。</p><h3 id="1-7-方法"><a href="#1-7-方法" class="headerlink" title="1.7 方法"></a>1.7 方法</h3><p>方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如<code>updateById</code>，<code>getUserInfo</code>.</p><p>如果是结构体方法，那么 <code>Receiver</code> 的名称应该缩写，一般使用一个或者两个字符作为 <code>Receiver</code> 的名称。如果 <code>Receiver</code> 是指针， 那么统一使用<code>p</code>。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (f foo) method() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *foo) method() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Receiver</code>命名应该统一， 要么都使用值， 要么都用指针。</p><h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h2><p>每个包都应该有一个包注释，位于 package 之前。如果同一个包有多个文件，只需要在一个文件中编写即可；如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2009 The Go Authors. All rights reserved.</span><br><span class="line">// Use of this source code is governed by a BSD-style</span><br><span class="line">// license that can be found in the LICENSE file.</span><br><span class="line"></span><br><span class="line">Package net provides a portable interface for network I/O, including</span><br><span class="line">TCP/IP, UDP, domain name resolution, and Unix domain sockets.</span><br><span class="line">package net</span><br></pre></td></tr></table></figure><p>每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Get 会响应对应路由转发过来的 get 请求</span><br><span class="line">func (c *Controller) Get() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在 <code>godoc</code> 中容易查找。</p><p>注释应该以一个句点 <code>.</code> 结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-命名&quot;&gt;&lt;a href=&quot;#1-命名&quot; class=&quot;headerlink&quot; title=&quot;1. 命名&quot;&gt;&lt;/a&gt;1. 命名&lt;/h2&gt;&lt;h3 id=&quot;1-1-文件命名&quot;&gt;&lt;a href=&quot;#1-1-文件命名&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件命名&quot;&gt;&lt;/a&gt;1.1 文件命名&lt;/h3&gt;&lt;p&gt;文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。&lt;br&gt;其中测试文件以&lt;code&gt;_test.go&lt;/code&gt;结尾，除测试文件外，命名不出现&lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子：&lt;code&gt;stringutil.go&lt;/code&gt;， &lt;code&gt;stringutil_test.go&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-package&quot;&gt;&lt;a href=&quot;#1-2-package&quot; class=&quot;headerlink&quot; title=&quot;1.2 package&quot;&gt;&lt;/a&gt;1.2 package&lt;/h3&gt;&lt;p&gt;包名用小写,使用短命名,尽量和标准库不要冲突。&lt;br&gt;包名统一使用单数形式。&lt;/p&gt;
&lt;h3 id=&quot;1-3-变量&quot;&gt;&lt;a href=&quot;#1-3-变量&quot; class=&quot;headerlink&quot; title=&quot;1.3 变量&quot;&gt;&lt;/a&gt;1.3 变量&lt;/h3&gt;&lt;p&gt;变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如DNS）的时候，特有名词根据是否私有全部大写或小写。&lt;/p&gt;
&lt;p&gt;例子： &lt;code&gt;apiClient&lt;/code&gt;、&lt;code&gt;URLString&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-4-常量&quot;&gt;&lt;a href=&quot;#1-4-常量&quot; class=&quot;headerlink&quot; title=&quot;1.4 常量&quot;&gt;&lt;/a&gt;1.4 常量&lt;/h3&gt;&lt;p&gt;同变量规则，力求语义表达完整清楚，不要嫌名字长。&lt;br&gt;如果模块复杂，为避免混淆，可按功能统一定义在&lt;code&gt;package&lt;/code&gt;下的一个文件中。&lt;/p&gt;
&lt;h3 id=&quot;1-5-接口&quot;&gt;&lt;a href=&quot;#1-5-接口&quot; class=&quot;headerlink&quot; title=&quot;1.5 接口&quot;&gt;&lt;/a&gt;1.5 接口&lt;/h3&gt;&lt;p&gt;单个函数的接口名以 &lt;code&gt;er&lt;/code&gt; 为后缀&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type Reader interface &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Read(p []byte) (n int, err error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两个函数的接口名综合两个函数名，如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type WriteFlusher interface &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Write([]byte) (int, error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Flush() error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;三个以上函数的接口名类似于结构体名，如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type Car interface &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Start() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Stop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Drive()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://blog.lichfaker.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker网络</title>
    <link href="http://blog.lichfaker.com/2018/04/04/Docker%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.lichfaker.com/2018/04/04/Docker网络/</id>
    <published>2018-04-04T12:26:31.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-NameSpace"><a href="#Linux-NameSpace" class="headerlink" title="Linux NameSpace"></a>Linux NameSpace</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法,用来让运行在同一个操作系统上的进程互相不会干扰。</p><p>目前 linux 内核主要实现了以下几种不同的资源 namespace：</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">系统调用参数</th><th style="text-align:center">隔离的内容</th></tr></thead><tbody><tr><td style="text-align:center">Mount</td><td style="text-align:center">CLONE_NEWNS</td><td style="text-align:center">Mount points (since Linux 2.4.19)</td></tr><tr><td style="text-align:center">UTS</td><td style="text-align:center">CLONE_NEWUTS</td><td style="text-align:center">Hostname and NIS domain name (since Linux 2.6.19)</td></tr><tr><td style="text-align:center">IPC</td><td style="text-align:center">CLONE_NEWIPC</td><td style="text-align:center">System V IPC, POSIX message queues (since Linux 2.6.19)</td></tr><tr><td style="text-align:center">PID</td><td style="text-align:center">CLONE_NEWPID</td><td style="text-align:center">Process IDs (since Linux 2.6.24)</td></tr><tr><td style="text-align:center">Network</td><td style="text-align:center">CLONE_NEWNET</td><td style="text-align:center">routing tables, firewall rules, the /proc/net and /sys/class/net directory trees, sockets, etc (since Linux 2.6.24)</td></tr><tr><td style="text-align:center">User</td><td style="text-align:center">CLONE_NEWUSER</td><td style="text-align:center">User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</td></tr><tr><td style="text-align:center">Cgroup</td><td style="text-align:center">CLONE_NEWCGROUP</td><td style="text-align:center">Cgroup root directory (since Linux 4.6)</td></tr></tbody></table><p>这里主要分析Linux的<code>Network Namespace</code>：<code>Network namespace</code> 是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中。</p><p>一个物理网络设备只能出现在最多一个网络 <code>Namespace</code> 中，不同网络 <code>Namespace</code> 之间可以通过创建 veth pair 提供类似管道的通信。</p><a id="more"></a><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>默认情况下，是没有<code>Namespace</code>的， 可通过命令<code>sudo ip netns list</code>验证， 输出为空。</p><p>创建 <code>Network Namespace</code> 也很简单， 通过命令 <code>sudo ip netns add</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip netns add test1</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns add test2</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns list</span><br><span class="line">test2</span><br><span class="line">test1</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test2 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">[vagrant@localhost ~]$</span><br></pre></td></tr></table></figure><p>上述操作创建了两个<code>Network Namespace</code>： test1和test2，同时在相应的 <code>Namespace</code> 下，查看 <code>ip a</code>均得到一个本地的<code>lo</code>口，并且是 DOWN 的。 </p><p>可通过命令<code>ip netns exec test1 ip link set dev lo up</code> 开启:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip link set dev lo up</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h3 id="Namespace-之间通信"><a href="#Namespace-之间通信" class="headerlink" title="Namespace 之间通信"></a>Namespace 之间通信</h3><p>linux 提供了 <code>veth pair</code> 来连接两个网络，<code>veth pair</code> 无法单独存在，删除其中一个，另一个也会自动消失。</p><p>我们可以将 <code>Namespace</code> 想像成电脑的网口， <code>veth pair</code> 想象成网线， 只要用网线将两个网口连接， 那么他们之间就可以通信了。 具体操作如下：</p><ol><li><p>创建一对 <code>veth pair</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip link add veth-test1 type veth peer name veth-test2</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 52:54:00:da:a7:10 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:7f:67:79 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:fa:d8:87:9c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">9: veth-test2@veth-test1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether f2:8e:3f:90:a6:86 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">10: veth-test1@veth-test2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether ae:74:c3:98:21:a9 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>veth</code> 到 <code>Namespace</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip link set veth-test1 netns test1</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">10: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether ae:74:c3:98:21:a9 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">[vagrant@localhost ~]$ ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 52:54:00:da:a7:10 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:7f:67:79 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:fa:d8:87:9c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">9: veth-test2@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether f2:8e:3f:90:a6:86 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p> 可以看到，veth-test1 已经添加到了 test1 下，test1 下多了一个网络接口 veth-test1@if9 ；用同样的方式添加veth-test2到 test2 下。</p></li><li><p>分配ip地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip addr add 177.60.1.100/24 dev veth-test1</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test2 ip addr add 177.60.1.101/24 dev veth-test2</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">10: veth-test1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether ae:74:c3:98:21:a9 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 177.60.1.100/24 scope global veth-test1</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test2 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">9: veth-test2@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    link/ether f2:8e:3f:90:a6:86 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 177.60.1.101/24 scope global veth-test2</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p> 可以看到ip地址已经添加成功了， 但是接口的状态还是 DOWN 的， 接下来我们只要将接口 UP ，那么test1 和 test2 之间就可以通信了：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip link set dev veth-test1 up</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test2 ip link set dev veth-test2 up</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ping 177.60.1.101</span><br><span class="line">PING 177.60.1.101 (177.60.1.101) 56(84) bytes of data.</span><br><span class="line">64 bytes from 177.60.1.101: icmp_seq=1 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 177.60.1.101: icmp_seq=2 ttl=64 time=0.039 ms</span><br><span class="line">64 bytes from 177.60.1.101: icmp_seq=3 ttl=64 time=0.040 ms</span><br><span class="line">64 bytes from 177.60.1.101: icmp_seq=4 ttl=64 time=0.054 ms</span><br><span class="line">^C</span><br><span class="line">--- 177.60.1.101 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3001ms</span><br><span class="line">rtt min/avg/max/mdev = 0.039/0.048/0.060/0.010 ms</span><br></pre></td></tr></table></figure></li></ol><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>前面已经实现了两个 <code>Namespace</code> 之间的通信，多个 <code>Namespace</code> 的通信可以通过 <code>bridge</code> 实现， 可以将其想象成交换机。 具体实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个bridge 并启用</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link add bridge-test type bridge</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set dev bridge-test up</span><br><span class="line"># 创建一对veth pair</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link add v1 type veth peer name v11</span><br><span class="line"># 分别添加到 bridge 和 test1</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set dev v1 master bridge-test</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set v11 netns test1</span><br><span class="line"># 为v11添加地址 10.0.0.10</span><br><span class="line">sudo ip netns exec test1 ip addr add 10.0.0.10/24 dev v11</span><br><span class="line"># 启用v1 及 v11</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set dev v1 up</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ip link set dev v11 up</span><br><span class="line"># test2 同理</span><br><span class="line"># 创建一对veth pair</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link add v2 type veth peer name v22</span><br><span class="line"># 分别添加到 bridge 和 test2</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set dev v2 master bridge-test</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set v22 netns test2</span><br><span class="line"># 为v22添加地址 10.0.0.11</span><br><span class="line">sudo ip netns exec test1 ip addr add 10.0.0.11/24 dev v22</span><br><span class="line"># 启用v2 及 v22</span><br><span class="line">[vagrant@localhost ~]$ sudo ip link set dev v2 up</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test2 ip link set dev v22 up</span><br><span class="line"># ping 验证</span><br><span class="line">[vagrant@localhost ~]$ sudo ip netns exec test1 ping 10.0.0.11</span><br><span class="line">PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=0.082 ms</span><br><span class="line">64 bytes from 10.0.0.11: icmp_seq=3 ttl=64 time=0.050 ms</span><br><span class="line">64 bytes from 10.0.0.11: icmp_seq=4 ttl=64 time=0.052 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.11 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3003ms</span><br><span class="line">rtt min/avg/max/mdev = 0.050/0.061/0.082/0.012 ms</span><br></pre></td></tr></table></figure><h2 id="Docker-bridge"><a href="#Docker-bridge" class="headerlink" title="Docker bridge"></a>Docker bridge</h2><p><code>Docker Daemon</code> 会创建出一个名为 <code>docker0</code> 的虚拟网桥 ，用来连接宿主机与容器，或者连接不同的容器。</p><p>当容器创建的时候， <code>Docker Daemon</code> 在宿主机上创建了两个虚拟网络接口 veth0 和 veth1，分别添加到docker0和对应的容器上， 从而实现容器间的通信。 其原理大致与 <code>Linux</code> 下的 <code>bridge</code> 相同。</p><p><code>Docker</code> 中创建容器默认的 <code>network</code> 是 <code>docker0</code>, 也可以创建自己的<code>bridge</code></p><pre><code>[vagrant@localhost ~]$ sudo docker network create -d bridge my-docker-bridgee3c0e8a86be9be336227e6479dc4d84599b613aa98722d19ae1ed635dd7170a1</code></pre><p>指定容器的 <code>network</code> 为自定义的 <code>bridge</code>：</p><ul><li>创建时指定： <code>docker run --name test1 --network my-docker-bridge busybox</code></li><li><code>docker network connect my-docker-bridge test1</code></li></ul><p><strong>区别：</strong> 自定义的 <code>bridge上</code> 的容器可以通过容器name访问（相当于做了DNS，互相<code>docker link</code>），而默认的<code>bridge</code> 则需额外指定。</p><h2 id="host-amp-amp-none"><a href="#host-amp-amp-none" class="headerlink" title="host &amp;&amp; none"></a>host &amp;&amp; none</h2><p>docker 中除了 bridge 还有 host 和 none 的网络。</p><p>host：跟宿主机共享一个 <code>Namespace</code> ； </p><p>none：不创建网络</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-NameSpace&quot;&gt;&lt;a href=&quot;#Linux-NameSpace&quot; class=&quot;headerlink&quot; title=&quot;Linux NameSpace&quot;&gt;&lt;/a&gt;Linux NameSpace&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Linux Namespace是Linux提供的一种内核级别环境隔离的方法,用来让运行在同一个操作系统上的进程互相不会干扰。&lt;/p&gt;
&lt;p&gt;目前 linux 内核主要实现了以下几种不同的资源 namespace：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;分类&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;系统调用参数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;隔离的内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Mount&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWNS&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Mount points (since Linux 2.4.19)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;UTS&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWUTS&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Hostname and NIS domain name (since Linux 2.6.19)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IPC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWIPC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;System V IPC, POSIX message queues (since Linux 2.6.19)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;PID&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWPID&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Process IDs (since Linux 2.6.24)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Network&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWNET&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;routing tables, firewall rules, the /proc/net and /sys/class/net directory trees, sockets, etc (since Linux 2.6.24)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;User&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWUSER&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Cgroup&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CLONE_NEWCGROUP&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Cgroup root directory (since Linux 4.6)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里主要分析Linux的&lt;code&gt;Network Namespace&lt;/code&gt;：&lt;code&gt;Network namespace&lt;/code&gt; 是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中。&lt;/p&gt;
&lt;p&gt;一个物理网络设备只能出现在最多一个网络 &lt;code&gt;Namespace&lt;/code&gt; 中，不同网络 &lt;code&gt;Namespace&lt;/code&gt; 之间可以通过创建 veth pair 提供类似管道的通信。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.lichfaker.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像和容器</title>
    <link href="http://blog.lichfaker.com/2018/03/20/Docker%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://blog.lichfaker.com/2018/03/20/Docker镜像和容器/</id>
    <published>2018-03-20T13:29:38.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker 是一个开源工具，可以将应用打包成一个标准格式的镜像文件，并且以容器的方式运行。</p><p>镜像特点：</p><ul><li>文件和<code>meta data</code>的集合(root filesystem)</li><li>image是分层的，每一层可以添加修改删除文件，成为一个新的image</li><li>不同的image可以共享相同的layer</li><li>本身是只读的</li></ul><p>容器特点：</p><ul><li>轻量： 在同一台宿主机上的容器共享系统Kernel，这使得他们可以快速启动。</li><li>安全：容器之间相互隔离，确保容器内应用不受外部环境影响。</li></ul><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><code>Docker</code>的镜像实际上由一层一层的文件系统组成，这种层级的文件系统被称为<code>UnionFS</code>。镜像可以基于<code>Dockerfile</code>构建，<code>Dockerfile</code>是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构; 也可以从<code>docker hub</code>上pull一个别人上传好的镜像。<br><a id="more"></a></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FROM scratch</code> 构建基础镜像；一般情况下使用官方仓库存储的镜像作为基础镜像。</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>类似注释，如记录许可信息，作者信息或其他信息。</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br></pre></td></tr></table></figure><p>RUN指令将在当前image之上的新层中执行任何命令，并提交结果。生成的已提交image将用于Dockerfile中的下一步。</p><p>每次执行RUN指令都将新开一层，所以我们应尽可能合并RUN指令， 最小化层数。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br></pre></td></tr></table></figure><p>在<code>Dockerfile</code>中只能有一个<code>CMD</code>指令。如果您列出多个<code>CMD</code>，则只有最后一个<code>CMD</code>将生效。</p><p><strong>注意</strong>： CMD 能够被 docker run 后面跟的命令行参数替换。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 指令可让容器以应用程序或者服务的形式运行。</p><p><code>ENTRYPOINT</code> 看上去与 <code>CMD</code> 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 <code>ENTRYPOINT</code> 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h4 id="AND-amp-amp-COPY"><a href="#AND-amp-amp-COPY" class="headerlink" title="AND &amp;&amp; COPY"></a>AND &amp;&amp; COPY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line">ADD URL</span><br><span class="line">COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><ul><li><code>COPY</code>: 只支持将本地文件复制到容器中</li><li><code>ADD</code>: 除了拷贝的作用，还支持添加远程URL连接以及自动解压压缩文件</li></ul><blockquote><p>对于不需要自动提取功能的其他项目（文件，目录），您应该始终使用 COPY。</p></blockquote><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line"># or</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure><p>定义匿名卷: 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中；在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>构建镜像时，<code>Docker</code>需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含<code>Dockerfile</code>目录中的所有文件，但是实际上，我们可能并不需要类似.git，build等内容。 </p><p><code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少<code>Docker</code>镜像的大小。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查看镜像</span><br><span class="line">docker image ls </span><br><span class="line">docker images</span><br><span class="line">// 拉取镜像</span><br><span class="line">docker pull debian</span><br><span class="line">// 交互式运行镜像</span><br><span class="line">docker run -it debian</span><br><span class="line">// 删除镜像</span><br><span class="line">docker rmi [image ID]</span><br><span class="line">// 删除所有镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器删除而丢失</strong>。</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 创建并运行容器</span><br><span class="line">docker run</span><br><span class="line">// 启动已存在容器</span><br><span class="line">docker container start</span><br><span class="line">// 查看容器</span><br><span class="line">docker container ls -a</span><br><span class="line">docker ps -a</span><br><span class="line">// 进入容器</span><br><span class="line">docker exec </span><br><span class="line">docker attach</span><br><span class="line">// 导出容器</span><br><span class="line">docker export</span><br><span class="line">// 导入容器</span><br><span class="line">docker import</span><br><span class="line">// 删除容器</span><br><span class="line">docker container rm</span><br><span class="line">docker rm</span><br><span class="line">// 删除所有容器</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Docker 是一个开源工具，可以将应用打包成一个标准格式的镜像文件，并且以容器的方式运行。&lt;/p&gt;
&lt;p&gt;镜像特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件和&lt;code&gt;meta data&lt;/code&gt;的集合(root filesystem)&lt;/li&gt;
&lt;li&gt;image是分层的，每一层可以添加修改删除文件，成为一个新的image&lt;/li&gt;
&lt;li&gt;不同的image可以共享相同的layer&lt;/li&gt;
&lt;li&gt;本身是只读的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量： 在同一台宿主机上的容器共享系统Kernel，这使得他们可以快速启动。&lt;/li&gt;
&lt;li&gt;安全：容器之间相互隔离，确保容器内应用不受外部环境影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;的镜像实际上由一层一层的文件系统组成，这种层级的文件系统被称为&lt;code&gt;UnionFS&lt;/code&gt;。镜像可以基于&lt;code&gt;Dockerfile&lt;/code&gt;构建，&lt;code&gt;Dockerfile&lt;/code&gt;是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构; 也可以从&lt;code&gt;docker hub&lt;/code&gt;上pull一个别人上传好的镜像。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.lichfaker.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境搭建</title>
    <link href="http://blog.lichfaker.com/2018/03/16/Docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.lichfaker.com/2018/03/16/Docker环境搭建/</id>
    <published>2018-03-16T11:39:27.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vagrant方式"><a href="#Vagrant方式" class="headerlink" title="Vagrant方式"></a>Vagrant方式</h2><p>一般我们使用<code>docker</code>是在<code>linux</code>环境中，所以这里使用虚拟机的方式来安装搭建<code>docker</code>环境，同时在实验练习的时候，其安装的一些镜像、插件不会影响到本机环境，只需在结束的时候删除整个虚拟机即可。</p><p>而<code>Vagrant</code>是一个虚拟机管理软件，它可以帮我们快速安装配置和管理虚拟机。</p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ol><li><p>首先需要依赖安装<code>VirtualBox</code>或者<code>VMWare</code></p></li><li><p>官网下载符合版本的Vagrant，<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">链接</a></p></li><li><p>在官网上搜索需要的<code>box</code>系统镜像文件，<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">链接</a></p></li><li><p>手动下载镜像文件，在搜索到的镜像页面中，选择版本，在该链接后拼接<code>/providers/virtualbox.box</code>就是下载地址，以centos7为例，下载地址就是：<br><a href="https://app.vagrantup.com/centos/boxes/7/versions/1802.01/providers/virtualbox.box" target="_blank" rel="noopener">https://app.vagrantup.com/centos/boxes/7/versions/1802.01/providers/virtualbox.box</a></p></li><li><p>新建一个空文件夹, 在终端命令行执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos /path/to/centos.box</span><br><span class="line">vagrant init centos</span><br><span class="line"># vagrant up 成功后会在virtualbox上创建一个centos的虚拟机</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh // ssh</span><br><span class="line">vagrant halt // 关机</span><br><span class="line">vagrant status // 查看状态</span><br><span class="line">vagrant destory // 删除虚拟机</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>首先<code>vagrant ssh</code>进入虚拟机。</p><p>根据官方文档， 依次执行以下命令：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br><span class="line"></span><br><span class="line"># Uninstall older versions of Docker, along with associated dependencies.</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"># Install required packages.</span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"># Set up the stable repository. </span><br><span class="line"># http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo may faster in China</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># Install the latest version of Docker CE</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"># Start docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p>除了以上方式，还可以用Vagrant的Shell Script功能：</p><p>在<code>vagrant init</code>后会生成一个<code>Vagrantfile</code>文件，可以配置一些虚拟机相关的参数，其中有一个Shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Enable provisioning with a shell script. Additional provisioners such as</span><br><span class="line"># Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the</span><br><span class="line"># documentation for more information about their specific syntax and use.</span><br><span class="line"># config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL</span><br><span class="line">#   apt-get update</span><br><span class="line">#   apt-get install -y apache2</span><br><span class="line"># SHELL</span><br></pre></td></tr></table></figure><p>简单来说就是将上面的一些安装命令写在<code>Vagrantfile</code>的<code>SHELL</code>中， 这样每次安装<code>up</code>的时候就会自动安装<code>docker</code></p><h2 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker machine"></a>docker machine</h2><p>docker machine 是一个能自动在虚拟机上安装docker engine的工具。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker for Mac、Docker for Windows 自带 docker-machine 二进制包，安装之后即可使用。</p><p>也可以单独下载安装，<a href="https://docs.docker.com/machine/install-machine/#install-machine-directly" target="_blank" rel="noopener">文档</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>创建一台 Docker 主机，命名为 test</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create test</span><br></pre></td></tr></table></figure><p> 在创建时也可以指定<code>driver</code>，如<code>virtualbox</code>，<code>xhyve</code>等。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox test</span><br></pre></td></tr></table></figure><p> 同时可以跟一些配置参数， 如: <code>--engine-registry-mirror https://registry.docker-cn.com</code> 配置 Docker 的仓库镜像；更多参数请使用 <code>docker-machine create --driver virtualbox --help</code> 命令查看。</p></li><li><p>查看主机</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure></li><li><p>设置当前docker engine为目标主机<br>执行<code>docker-machine env test</code>，输出如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_TLS_VERIFY=&quot;1&quot;</span><br><span class="line">export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH=&quot;/Users/lichfaker/.docker/machine/machines/test&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME=&quot;test&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env test)</span><br></pre></td></tr></table></figure><p> 执行<code>eval $(docker-machine env test)</code>后，当前的<code>docker engine</code>就是<code>test</code>主机的，可以通过<code>docker version</code>查看验证。</p><p> 如果想要取消设置，<code>docker-machine env --unset</code>后根据提示操作即可。</p></li><li><p>登录到主机</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh test</span><br></pre></td></tr></table></figure></li><li><p>管理远程主机</p><ul><li>AWS： <a href="https://docs.docker.com/machine/drivers/aws/" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/aws/</a></li><li>Aliyun: <a href="https://github.com/AliyunContainerService/docker-machine-driver-aliyunecs" target="_blank" rel="noopener">https://github.com/AliyunContainerService/docker-machine-driver-aliyunecs</a></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com" target="_blank" rel="noopener">docker文档</a><br><a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">Vagrant文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vagrant方式&quot;&gt;&lt;a href=&quot;#Vagrant方式&quot; class=&quot;headerlink&quot; title=&quot;Vagrant方式&quot;&gt;&lt;/a&gt;Vagrant方式&lt;/h2&gt;&lt;p&gt;一般我们使用&lt;code&gt;docker&lt;/code&gt;是在&lt;code&gt;linux&lt;/code&gt;环境中，所以这里使用虚拟机的方式来安装搭建&lt;code&gt;docker&lt;/code&gt;环境，同时在实验练习的时候，其安装的一些镜像、插件不会影响到本机环境，只需在结束的时候删除整个虚拟机即可。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;Vagrant&lt;/code&gt;是一个虚拟机管理软件，它可以帮我们快速安装配置和管理虚拟机。&lt;/p&gt;
&lt;h3 id=&quot;安装使用&quot;&gt;&lt;a href=&quot;#安装使用&quot; class=&quot;headerlink&quot; title=&quot;安装使用&quot;&gt;&lt;/a&gt;安装使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要依赖安装&lt;code&gt;VirtualBox&lt;/code&gt;或者&lt;code&gt;VMWare&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网下载符合版本的Vagrant，&lt;a href=&quot;https://www.vagrantup.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在官网上搜索需要的&lt;code&gt;box&lt;/code&gt;系统镜像文件，&lt;a href=&quot;https://app.vagrantup.com/boxes/search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手动下载镜像文件，在搜索到的镜像页面中，选择版本，在该链接后拼接&lt;code&gt;/providers/virtualbox.box&lt;/code&gt;就是下载地址，以centos7为例，下载地址就是：&lt;br&gt;&lt;a href=&quot;https://app.vagrantup.com/centos/boxes/7/versions/1802.01/providers/virtualbox.box&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://app.vagrantup.com/centos/boxes/7/versions/1802.01/providers/virtualbox.box&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新建一个空文件夹, 在终端命令行执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant box add centos /path/to/centos.box&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant init centos&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# vagrant up 成功后会在virtualbox上创建一个centos的虚拟机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant up&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant ssh // ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant halt // 关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant status // 查看状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant destory // 删除虚拟机&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h3&gt;&lt;p&gt;首先&lt;code&gt;vagrant ssh&lt;/code&gt;进入虚拟机。&lt;/p&gt;
&lt;p&gt;根据官方文档， 依次执行以下命令：&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.lichfaker.com/tags/Docker/"/>
    
      <category term="Vagrant" scheme="http://blog.lichfaker.com/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>zsh中用户名主机隐藏</title>
    <link href="http://blog.lichfaker.com/2018/03/16/zsh%E4%B8%AD%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%BB%E6%9C%BA%E9%9A%90%E8%97%8F/"/>
    <id>http://blog.lichfaker.com/2018/03/16/zsh中用户名主机隐藏/</id>
    <published>2018-03-16T09:45:36.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<p>最近终端用的有点多，每次敲命令前看一长串<code>lichfaker@LichFakerdeMacBook-Pro</code>很不爽，有时命令稍微长点就会换行，于是就想着将它隐藏掉。</p><h2 id="修改bashrc"><a href="#修改bashrc" class="headerlink" title="修改bashrc"></a><del>修改bashrc</del></h2><p>网上搜了一圈，基本都是修改<code>etc/bashrc</code>文件中的<code>PS1</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1= &apos;\W \u\$ &apos;</span><br></pre></td></tr></table></figure><p>实践后发现并没有生效， 后知后觉： bashrc修改的应该是bash中的显示， 而我用的是<code>oh-my-zsh</code>。</p><h2 id="修改Zsh主题"><a href="#修改Zsh主题" class="headerlink" title="修改Zsh主题"></a>修改Zsh主题</h2><p>以<code>ZSH_THEME=&quot;agnoster&quot;</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/themes</span><br><span class="line">vi agnoster.zsh-theme</span><br></pre></td></tr></table></figure><p>其中有这么一段代码:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Context: user@hostname (who am I and where am I)</span><br><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER@%m&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Main prompt</span><br><span class="line">build_prompt() &#123;</span><br><span class="line">  RETVAL=$?</span><br><span class="line">  prompt_status</span><br><span class="line">  prompt_virtualenv</span><br><span class="line">  prompt_context</span><br><span class="line">  prompt_dir</span><br><span class="line">  prompt_git</span><br><span class="line">  prompt_bzr</span><br><span class="line">  prompt_hg</span><br><span class="line">  prompt_end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>修改<code>prompt_context()</code></li><li>注释 <code>prompt_context</code></li></ul><h2 id="修改zshrc"><a href="#修改zshrc" class="headerlink" title="修改zshrc"></a>修改zshrc</h2><p>上述直接修改主题的方式并不太友好，因为主题文件可能会随着<code>oh_my_zsh</code>的更新而有所改变。</p><p>在<a href="https://stackoverflow.com/questions/28491458/zsh-agnoster-theme-showing-machine-name" target="_blank" rel="noopener">ZSH Agnoster Theme showing machine name</a>上找到了一种更好的方式：</p><blockquote><p>Overriding the function prompt_context or build_prompt on Agnoster theme will rescue. Putting below snippets at the very end of the ~/.zshrc for example.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># redefine prompt_context for hiding user@hostname</span><br><span class="line">prompt_context () &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近终端用的有点多，每次敲命令前看一长串&lt;code&gt;lichfaker@LichFakerdeMacBook-Pro&lt;/code&gt;很不爽，有时命令稍微长点就会换行，于是就想着将它隐藏掉。&lt;/p&gt;
&lt;h2 id=&quot;修改bashrc&quot;&gt;&lt;a href=&quot;#修改bashrc&quot; class=&quot;headerlink&quot; title=&quot;修改bashrc&quot;&gt;&lt;/a&gt;&lt;del&gt;修改bashrc&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;网上搜了一圈，基本都是修改&lt;code&gt;etc/bashrc&lt;/code&gt;文件中的&lt;code&gt;PS1&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PS1= &amp;apos;\W \u\$ &amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实践后发现并没有生效， 后知后觉： bashrc修改的应该是bash中的显示， 而我用的是&lt;code&gt;oh-my-zsh&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;修改Zsh主题&quot;&gt;&lt;a href=&quot;#修改Zsh主题&quot; class=&quot;headerlink&quot; title=&quot;修改Zsh主题&quot;&gt;&lt;/a&gt;修改Zsh主题&lt;/h2&gt;&lt;p&gt;以&lt;code&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;&lt;/code&gt;为例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/.oh-my-zsh/themes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vi agnoster.zsh-theme&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中有这么一段代码:&lt;br&gt;
    
    </summary>
    
    
      <category term="tips" scheme="http://blog.lichfaker.com/tags/tips/"/>
    
      <category term="zsh" scheme="http://blog.lichfaker.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>cache2go源码分析</title>
    <link href="http://blog.lichfaker.com/2018/03/08/cache2go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.lichfaker.com/2018/03/08/cache2go源码分析/</id>
    <published>2018-03-08T11:58:50.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cache2go-简介"><a href="#cache2go-简介" class="headerlink" title="cache2go 简介"></a>cache2go 简介</h2><p><a href="https://github.com/muesli/cache2go" target="_blank" rel="noopener">cache2go</a>是一个用Go实现的并发安全的缓存库，实现了如下特性:</p><ul><li>并发安全</li><li>可设置缓存项的生命周期</li><li>包含缓存增加、删除的回调函数</li><li>内置缓存访问计数</li><li>…</li></ul><p>这个库代码量很少，核心代码就三个文件，里面设计的技术点主要包括读写锁、函数式编程、map操作等.</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="1-新建"><a href="#1-新建" class="headerlink" title="1. 新建"></a>1. 新建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache := cache2go.Cache(&quot;myCache&quot;)</span><br></pre></td></tr></table></figure><p>Example中是通过调用cache2go的<code>Cache</code>方法，参数是缓存<code>table</code>的唯一标识，返回了一个<code>CacheTable</code>的指针。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func Cache(table string) *CacheTable &#123;</span><br><span class="line">mutex.RLock()</span><br><span class="line">t, ok := cache[table]</span><br><span class="line">mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">if !ok &#123;</span><br><span class="line">mutex.Lock()</span><br><span class="line">t, ok = cache[table]</span><br><span class="line">// Double check whether the table exists or not.</span><br><span class="line">if !ok &#123;</span><br><span class="line">t = &amp;CacheTable&#123;</span><br><span class="line">name:  table,</span><br><span class="line">items: make(map[interface&#123;&#125;]*CacheItem),</span><br><span class="line">&#125;</span><br><span class="line">cache[table] = t</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟踪查看<code>Cache</code>方法：</p><ol><li>通过<strong>读锁</strong>来查看指定<code>table</code>是否存在，存在则返回，否则则创建</li><li>创建前增加一个<strong>互斥锁</strong>再次检查<code>table</code>是否存在，用来确保线程安全</li><li>创建的<code>table</code>都是存在一个全局的<code>map</code>变量中，其值类型是<code>CacheTable</code></li></ol><h3 id="2-CacheItem"><a href="#2-CacheItem" class="headerlink" title="2. CacheItem"></a>2. CacheItem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// CacheItem is an individual cache item</span><br><span class="line">// Parameter data contains the user-set value in the cache.</span><br><span class="line">type CacheItem struct &#123;</span><br><span class="line">    // 读写锁</span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 缓存项的key</span><br><span class="line">key interface&#123;&#125;</span><br><span class="line">// 缓存项的值.</span><br><span class="line">data interface&#123;&#125;</span><br><span class="line">// 缓存项的生命周期</span><br><span class="line">lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line">// 创建时间戳</span><br><span class="line">createdOn time.Time</span><br><span class="line">// 最近被访问的时间戳</span><br><span class="line">accessedOn time.Time</span><br><span class="line">// 被访问的次数</span><br><span class="line">accessCount int64</span><br><span class="line"></span><br><span class="line">// 被删除时的回调函数(删之前执行)</span><br><span class="line">aboutToExpire func(key interface&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheItem</code>定义了一些<code>Set</code>和<code>Get</code>方法，主要是对于结构体中定义的一些属性，其中<code>KeepAlive</code>方法会更新每次缓存访问的时间和命中次数.</p><h3 id="3-CacheTable"><a href="#3-CacheTable" class="headerlink" title="3. CacheTable"></a>3. CacheTable</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// CacheTable is a table within the cache</span><br><span class="line">type CacheTable struct &#123;</span><br><span class="line">    // 读写锁</span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 缓存表标识</span><br><span class="line">name string</span><br><span class="line">// 缓存项</span><br><span class="line">items map[interface&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line">// 触发缓存清理的定时器</span><br><span class="line">cleanupTimer *time.Timer</span><br><span class="line">// 下次缓存清理的时间</span><br><span class="line">cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line">// 该缓存表的日志</span><br><span class="line">logger *log.Logger</span><br><span class="line"></span><br><span class="line">// 获取一个不存在的缓存项时的回调函数</span><br><span class="line">loadData func(key interface&#123;&#125;, args ...interface&#123;&#125;) *CacheItem</span><br><span class="line">// 向缓存表新增缓存项时的回调函数</span><br><span class="line">addedItem func(item *CacheItem)</span><br><span class="line">// 向缓存表删除缓存项时的回调函数</span><br><span class="line">aboutToDeleteItem func(item *CacheItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查缓存过期"><a href="#检查缓存过期" class="headerlink" title="检查缓存过期"></a>检查缓存过期</h4><p>检查缓存失效方法<code>expirationCheck</code>主要是通过定时器或新增时主动调用来触发的，它主要做了以下几件事：</p><ol><li>对整个缓存表加锁, <code>table.Lock()</code></li><li>停止当前的缓存清理定时器<code>cleanupTimer</code></li><li>遍历当前缓存表中所有缓存项，删除已经失效的缓存项，同时找出最快即将失效的缓存时间</li><li>对缓存项的<code>lifeSpan==0</code>的当作永久缓存处理</li><li>遍历结束后，若还需要继续清理缓存，则更新下次清理缓存的时间，同时重新设置清理触发定时</li></ol><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Expiration check loop, triggered by a self-adjusting timer.</span><br><span class="line">func (table *CacheTable) expirationCheck() &#123;</span><br><span class="line">table.Lock()</span><br><span class="line">if table.cleanupTimer != nil &#123;</span><br><span class="line">table.cleanupTimer.Stop()</span><br><span class="line">&#125;</span><br><span class="line">if table.cleanupInterval &gt; 0 &#123;</span><br><span class="line">table.log(&quot;Expiration check triggered after&quot;, table.cleanupInterval, &quot;for table&quot;, table.name)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">table.log(&quot;Expiration check installed for table&quot;, table.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// To be more accurate with timers, we would need to update &apos;now&apos; on every</span><br><span class="line">// loop iteration. Not sure it&apos;s really efficient though.</span><br><span class="line">now := time.Now()</span><br><span class="line">smallestDuration := 0 * time.Second</span><br><span class="line">for key, item := range table.items &#123;</span><br><span class="line">// Cache values so we don&apos;t keep blocking the mutex.</span><br><span class="line">item.RLock()</span><br><span class="line">lifeSpan := item.lifeSpan</span><br><span class="line">accessedOn := item.accessedOn</span><br><span class="line">item.RUnlock()</span><br><span class="line"></span><br><span class="line">if lifeSpan == 0 &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if now.Sub(accessedOn) &gt;= lifeSpan &#123;</span><br><span class="line">// Item has excessed its lifespan.</span><br><span class="line">table.deleteInternal(key)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Find the item chronologically closest to its end-of-lifespan.</span><br><span class="line">if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Setup the interval for the next cleanup run.</span><br><span class="line">table.cleanupInterval = smallestDuration</span><br><span class="line">if smallestDuration &gt; 0 &#123;</span><br><span class="line">table.cleanupTimer = time.AfterFunc(smallestDuration, func() &#123;</span><br><span class="line">go table.expirationCheck()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">table.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增缓存项"><a href="#新增缓存项" class="headerlink" title="新增缓存项"></a>新增缓存项</h4><p>添加缓存项的方法主要在<code>addInternal</code>中：</p><ol><li>将缓存项存入<code>table</code>的<code>items</code>map中</li><li>调用新增缓存项时的回调函数<code>addedItem</code></li><li>若当前缓存生命周期不为0且小于最近失效的时间，则调用<code>expirationCheck</code>方法更新并清理</li></ol><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (table *CacheTable) addInternal(item *CacheItem) &#123;</span><br><span class="line">// Careful: do not run this method unless the table-mutex is locked!</span><br><span class="line">// It will unlock it for the caller before running the callbacks and checks</span><br><span class="line">table.log(&quot;Adding item with key&quot;, item.key, &quot;and lifespan of&quot;, item.lifeSpan, &quot;to table&quot;, table.name)</span><br><span class="line">table.items[item.key] = item</span><br><span class="line"></span><br><span class="line">// Cache values so we don&apos;t keep blocking the mutex.</span><br><span class="line">expDur := table.cleanupInterval</span><br><span class="line">addedItem := table.addedItem</span><br><span class="line">table.Unlock()</span><br><span class="line"></span><br><span class="line">// Trigger callback after adding an item to cache.</span><br><span class="line">if addedItem != nil &#123;</span><br><span class="line">addedItem(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If we haven&apos;t set up any expiration check timer or found a more imminent item.</span><br><span class="line">if item.lifeSpan &gt; 0 &amp;&amp; (expDur == 0 || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">table.expirationCheck()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>删除和查找跟添加类似，没有分析。总的来说<code>cache2go</code>不适合需要大量插入的项目，在每次插入时还要全部遍历检查生命周期，效率有点低下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cache2go-简介&quot;&gt;&lt;a href=&quot;#cache2go-简介&quot; class=&quot;headerlink&quot; title=&quot;cache2go 简介&quot;&gt;&lt;/a&gt;cache2go 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/muesli/cache2go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cache2go&lt;/a&gt;是一个用Go实现的并发安全的缓存库，实现了如下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发安全&lt;/li&gt;
&lt;li&gt;可设置缓存项的生命周期&lt;/li&gt;
&lt;li&gt;包含缓存增加、删除的回调函数&lt;/li&gt;
&lt;li&gt;内置缓存访问计数&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个库代码量很少，核心代码就三个文件，里面设计的技术点主要包括读写锁、函数式编程、map操作等.&lt;/p&gt;
&lt;h2 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink&quot; title=&quot;源码解析&quot;&gt;&lt;/a&gt;源码解析&lt;/h2&gt;&lt;h3 id=&quot;1-新建&quot;&gt;&lt;a href=&quot;#1-新建&quot; class=&quot;headerlink&quot; title=&quot;1. 新建&quot;&gt;&lt;/a&gt;1. 新建&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cache := cache2go.Cache(&amp;quot;myCache&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example中是通过调用cache2go的&lt;code&gt;Cache&lt;/code&gt;方法，参数是缓存&lt;code&gt;table&lt;/code&gt;的唯一标识，返回了一个&lt;code&gt;CacheTable&lt;/code&gt;的指针。&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://blog.lichfaker.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang并发编程</title>
    <link href="http://blog.lichfaker.com/2018/02/27/Golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.lichfaker.com/2018/02/27/Golang并发编程/</id>
    <published>2018-02-27T13:57:03.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在Go语言中，语言本身就已经实现和支持了并发， 我们只需要通过<code>go</code>关键字来开启<code>goroutine</code>即可。</p><p>gouroutine其实就是一种协程，类似其他语言中的coroutine， 是在编译器或虚拟机层面上的多任务。它可以运行在一个或多个线程上，但不同于线程，它是<strong>非抢占式的</strong>，所以协程很轻量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">    go func(ii int) &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            fmt.Printf(&quot;Hello %d\n&quot;, ii)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就开启了1000个协程，在1ms内不断的打印字符串，这里需要注意两个点：</p><ol><li><p>time.Sleep<br> 在main函数退出前，Sleep了1ms。这是因为当main函数退出时，之前开的协程也会随着退出，如果不Sleep，则无法看到打印信息。</p></li><li><p>匿名函数将变量i作为参数赋值传入。<br> 如果不传参，变量i也能被使用，但是是以引用的方式。而i在main函数中在不断自增，导致在goroutine打印信息中，无法知道是第几个协程打印的。</p></li></ol><p>从打印信息上看，跟开线程没什么区别，无非就是数量上不同。但是在操作系统层面，线程是抢占式，而我们之前说协程是非抢占式的，这怎么会一样呢？</p><a id="more"></a><p>出现上述问题的原因在于，在调用<code>Printf</code>的时候，进行了切换， goroutine主动让出了控制权。我们修改代码如下，演示下非抢占：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a := [10]int&#123;&#125;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    go func(ii int) &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            a[ii]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure><p>运行上述代码，出现了死循环。因为在开辟的第一个goroutine中，一直循环执行<code>a[ii]++</code>，一直没有让出控制权；而<code>main</code>本质上也是个goroutine，所以后面的代码都没有执行完，也没有退出。</p><p>遇到这种情况，我们可以在goroutine中主动让出控制权，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[ii]++</span><br><span class="line">runtime.Gosched()</span><br></pre></td></tr></table></figure><p>goroutine 可能会切换的点 （不能保证）:</p><ul><li>I/O,select</li><li>channel</li><li>等待锁</li><li>runtime.Gosched()</li></ul><h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><p>Go实现了两种并发形式：</p><ol><li>共享内存 + 锁同步</li><li>CSP. 通过goroutine和channel来实现的.</li></ol><p>CSP并发模型是在1970年左右提出的概念，属于比较新的概念，不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating<br>不要以共享内存的方式来通信，相反，要通过通信来共享内存。</p></blockquote><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel 是用来在不同goroutine之间进行通信的，无论传值还是取值， 它都是阻塞的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line">c &lt;- 1</span><br></pre></td></tr></table></figure><p>上面代码直接运行会造成死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>所以一般在使用channel前先开一个goroutine去接收channel:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func createWorker() chan int &#123;</span><br><span class="line">    c := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for n := range c &#123;</span><br><span class="line">            fmt.Println(&quot;received:&quot;, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var channels [10]chan int</span><br><span class="line"></span><br><span class="line">    for i, _ := range channels &#123;</span><br><span class="line">        channels[i] = createWorker()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i, c := range channels &#123;</span><br><span class="line">        c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个<code>createWorker</code>，用来创建一个接收者，同时返回了一个channel。同时我们可以对返回的channel做限制，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func createWorker() chan&lt;- int // 只能发送数据</span><br><span class="line">func createWorker() &lt;-chan int // 只能接收数据</span><br></pre></td></tr></table></figure><p>一般可以通过<code>n := &lt;- c</code>来接收数据，在上述例子中使用了range，因为channel是可以close的。</p><p><code>close(c)</code>关闭channel， 但是关闭后在worker中依然能接收到channel（只要goroutine没有退出）。而接收到的数据是定义的channel的零值，在上述例子中，则收到0.</p><ul><li><p>通过<code>n,ok := &lt;- c</code>的ok来判断channel是否关闭；也可以通过range来接收；</p></li><li><p>如果往已经关闭的channel写数据，会panic：<code>send on closed channel</code>. <strong>不要从接收端关闭channel，也不要关闭有多个并发发送者的channel</strong></p></li></ul><h3 id="等待任务结束"><a href="#等待任务结束" class="headerlink" title="等待任务结束"></a>等待任务结束</h3><p>在之前的例子中，我们都是通过Sleep方法来粗略的控制任务的执行，这在实际生产中肯定不能这么干。之前也说了channel是用来通信的，那么我们可以通过channel来告诉使用者任务已经执行完了。 代码优化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type worker struct &#123;</span><br><span class="line">    in   chan int</span><br><span class="line">    done chan bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createWorker() worker &#123;</span><br><span class="line">    w := worker&#123;</span><br><span class="line">        in:   make(chan int),</span><br><span class="line">        done: make(chan bool),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func(w worker) &#123;</span><br><span class="line">        for n := range w.in &#123;</span><br><span class="line">            fmt.Println(&quot;received:&quot;, n)</span><br><span class="line">            w.done &lt;- true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(w)</span><br><span class="line"></span><br><span class="line">    return w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func chanNormal() &#123;</span><br><span class="line">    var workers [10]worker</span><br><span class="line"></span><br><span class="line">    for i, _ := range workers &#123;</span><br><span class="line">        workers[i] = createWorker()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i, w := range workers &#123;</span><br><span class="line">        w.in &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, w := range workers &#123;</span><br><span class="line">        &lt;-w.done</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chanNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了我们自己定义channel，go也为我们提供了<code>sync.WaitGroup</code>，来管理一组任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(1)</span><br><span class="line">wg.Done()</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>将struct中的done抽象成一个方法，在<code>create</code>的时候实现，这样在<code>worker</code>中就不用管具体代码了，只要调用done方法即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Goroutine&quot;&gt;&lt;a href=&quot;#Goroutine&quot; class=&quot;headerlink&quot; title=&quot;Goroutine&quot;&gt;&lt;/a&gt;Goroutine&lt;/h2&gt;&lt;p&gt;在Go语言中，语言本身就已经实现和支持了并发， 我们只需要通过&lt;code&gt;go&lt;/code&gt;关键字来开启&lt;code&gt;goroutine&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;gouroutine其实就是一种协程，类似其他语言中的coroutine， 是在编译器或虚拟机层面上的多任务。它可以运行在一个或多个线程上，但不同于线程，它是&lt;strong&gt;非抢占式的&lt;/strong&gt;，所以协程很轻量。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for i := 0; i &amp;lt; 1000; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    go func(ii int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fmt.Printf(&amp;quot;Hello %d\n&amp;quot;, ii)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time.Sleep(time.Millisecond)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码就开启了1000个协程，在1ms内不断的打印字符串，这里需要注意两个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;time.Sleep&lt;br&gt; 在main函数退出前，Sleep了1ms。这是因为当main函数退出时，之前开的协程也会随着退出，如果不Sleep，则无法看到打印信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;匿名函数将变量i作为参数赋值传入。&lt;br&gt; 如果不传参，变量i也能被使用，但是是以引用的方式。而i在main函数中在不断自增，导致在goroutine打印信息中，无法知道是第几个协程打印的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从打印信息上看，跟开线程没什么区别，无非就是数量上不同。但是在操作系统层面，线程是抢占式，而我们之前说协程是非抢占式的，这怎么会一样呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://blog.lichfaker.com/tags/Golang/"/>
    
      <category term="并发" scheme="http://blog.lichfaker.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Golang面向对象和接口编程</title>
    <link href="http://blog.lichfaker.com/2018/02/16/Golang%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.lichfaker.com/2018/02/16/Golang面向对象和接口编程/</id>
    <published>2018-02-16T20:15:35.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>早期编程是面向过程的，比如C语言。面向过程编程在构造系统时，无法解决重用，维护，扩展的问题，而且逻辑过于复杂，代码晦涩难懂，因此产生了面向对象编程思想：把构成问题的各个事物分解成各个对象，对象作为程序的基本单位，将程序和数据封装其中，以提高程序的重用性，灵活性和可扩展性。（封装、继承、多态）</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>GO语言没有class，只有struct</li><li>GO语言仅支持封装。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Node struct &#123;</span><br><span class="line">Value int</span><br><span class="line">Left  *Node</span><br><span class="line">Right *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *Node) SetValue(value int) &#123;</span><br><span class="line">node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *Node) Traverse() &#123;</span><br><span class="line">if node == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node.Left.Traverse()</span><br><span class="line">node.Print()</span><br><span class="line">node.Right.Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *Node) Print() &#123;</span><br><span class="line">fmt.Print(node.Value, &quot; &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>说明几个地方：</p><ol><li>结构体内只定义属性，方法则是定义在结构体外的</li><li>GO没有构造函数， 一般通过工厂函数来创建返回对象</li><li>上述*Node为receiver，接收者， 它既可以传值也可以传指针；一般情况下，它的类型应该统一，当需要改变结构体内容的时候或者结构体很大时，需要传递指针。</li><li>如果接收者为指针，也可以通过值对象访问，GO会自动取其地址， 反之则不行.</li><li>nil指针也可以调用方法，某些情况下需要特殊处理。</li><li>首字母大写： public；首字母小写：private （针对包范围）</li></ol><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var root tree.Node</span><br><span class="line">root.SetValue(8)</span><br><span class="line"></span><br><span class="line">root.Left = &amp;tree.Node&#123;&#125;</span><br><span class="line">root.Right = &amp;tree.Node&#123;5, nil, nil&#125;</span><br><span class="line">root.Right.Left = new(tree.Node)</span><br><span class="line">root.Left.Right = new(tree.Node)</span><br><span class="line">root.Left.Right.SetValue(6)</span><br><span class="line">root.Right.Left.SetValue(4)</span><br><span class="line"></span><br><span class="line">root.Traverse() // 0,6,8,4,5</span><br></pre></td></tr></table></figure><h4 id="扩展已有类型"><a href="#扩展已有类型" class="headerlink" title="扩展已有类型"></a>扩展已有类型</h4><p>由于在Golang中，为结构体创建的方法必须在一个保内，且对象不支持继承。但它提供了两种方法来扩充系统类型或者别人的类型：定义别名；使用组合。</p><h5 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h5><p>在Slice的基础上实现队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package queue</span><br><span class="line"></span><br><span class="line">type Queue []interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Push(obj interface&#123;&#125;) &#123;</span><br><span class="line">*q = append(*q, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) Pop() interface&#123;&#125; &#123;</span><br><span class="line">if q.IsEmpty() &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">head := (*q)[0]</span><br><span class="line">*q = (*q)[1:]</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (q *Queue) IsEmpty() bool &#123;</span><br><span class="line">return len(*q) &lt;= 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">queue := Queue&#123;&#125;</span><br><span class="line"></span><br><span class="line">queue.Push(&quot;Hello&quot;)</span><br><span class="line">queue.Push(1)</span><br><span class="line">queue.Push(1.5)</span><br><span class="line">queue.Push(true)</span><br><span class="line"></span><br><span class="line">fmt.Println(queue.Pop())</span><br><span class="line">fmt.Println(queue.Pop())</span><br><span class="line">fmt.Println(queue.IsEmpty())</span><br><span class="line">fmt.Println(queue.Pop())</span><br><span class="line">fmt.Println(queue.Pop())</span><br><span class="line">fmt.Println(queue.IsEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用组合"><a href="#使用组合" class="headerlink" title="使用组合"></a>使用组合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 组合方式扩展</span><br><span class="line">type myNode struct &#123;</span><br><span class="line">node *tree.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展：前序遍历</span><br><span class="line">func (node *myNode) preOrder() &#123;</span><br><span class="line">if node == nil || node.node == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node.node.Print()</span><br><span class="line"></span><br><span class="line">left := myNode&#123;node.node.Left&#125;</span><br><span class="line">right := myNode&#123;node.node.Right&#125;</span><br><span class="line"></span><br><span class="line">left.preOrder()</span><br><span class="line">right.preOrder()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承（Composition）"><a href="#继承（Composition）" class="headerlink" title="继承（Composition）"></a><del>继承</del>（Composition）</h3><p>之前也说过，Golang中不支持继承，但是提供了Composition。</p><p>Golang中的Compostion有两种形式, 匿名组合(Pseudo is-a)和非匿名组合(has-a)。</p><h4 id="匿名组合"><a href="#匿名组合" class="headerlink" title="匿名组合"></a>匿名组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Human struct &#123;</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (Human) Speak() &#123;</span><br><span class="line">fmt.Println(&quot;Hello!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Teacher struct &#123;</span><br><span class="line">Human</span><br><span class="line">Name    string</span><br><span class="line">School  string</span><br><span class="line">Subject string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t Teacher) Speak() &#123;</span><br><span class="line">fmt.Printf(&quot;My name is %s, I teach %s&quot;, t.Name, t.Subject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">t := Teacher&#123;Human: Human&#123;</span><br><span class="line">&quot;Bob&quot;,</span><br><span class="line">18,</span><br><span class="line">&#125;,</span><br><span class="line">Name:    &quot;John&quot;,</span><br><span class="line">School:  &quot;MIT&quot;,</span><br><span class="line">Subject: &quot;CS&quot;,</span><br><span class="line">&#125;</span><br><span class="line">// My name is John, I teach CS</span><br><span class="line">t.Speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非匿名组合"><a href="#非匿名组合" class="headerlink" title="非匿名组合"></a>非匿名组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Student struct &#123;</span><br><span class="line">    h      Human //非匿名字段</span><br><span class="line">    school string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向接口"><a href="#面向接口" class="headerlink" title="面向接口"></a>面向接口</h2><h3 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h3><p>Golang不同于其他语言，接口是由使用者定义，而实现是隐式的， 只需实现接口中定义的方法即可。</p><h3 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;早期编程是面向过程的，比如C语言。面向过程编程在构造系统时，无法解决重用，维护，扩展的问题，而且逻辑过于复杂，代码晦涩难懂，因此产生了面向对象编程思想：把构成问题的各个事物分解成各个对象，对象作为程序的基本单位，将程序和数据封装其中，以提高程序的重用性，灵活性和可扩展性。（封装、继承、多态）&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;GO语言没有class，只有struct&lt;/li&gt;
&lt;li&gt;GO语言仅支持封装。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type Node struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Value int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Left  *Node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Right *Node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (node *Node) SetValue(value int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	node.Value = value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (node *Node) Traverse() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if node == nil &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	node.Left.Traverse()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	node.Print()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	node.Right.Traverse()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (node *Node) Print() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Print(node.Value, &amp;quot; &amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://blog.lichfaker.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang学习——基础语法</title>
    <link href="http://blog.lichfaker.com/2018/01/20/Golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://blog.lichfaker.com/2018/01/20/Golang学习之基础语法/</id>
    <published>2018-01-20T11:30:34.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>命名规则同其他语言一样，以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。其中大写字母开头的，可以被其他包访问(相当于<code>public</code>)；否则只能在包内使用(相当于<code>private</code>)。</p><p>常量、变量、类型、接口、结构、函数等的名称命名规则均一样。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>按照Go语言规范，任何类型在未初始化时都对应一个零值：布尔类型是false，整型是0，字符串是””，而指针，函数，interface，slice，channel和map的零值都是nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str string // str == &quot;&quot;</span><br><span class="line">var i int      // i == 0</span><br><span class="line">var f float64  // f == 0</span><br><span class="line">var p *int     // p == nil</span><br><span class="line">s := &quot;hello&quot;   // 只能在函数或者方法内</span><br><span class="line">p2 := new(int) // p2, *int 类型, 指向匿名的 int 变量</span><br></pre></td></tr></table></figure><a id="more"></a><p>go 语言中没有使用的包或者变量，会导致编译失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//&quot;net/http&quot; 包导入不使用，如果包里面有 init 方法，只执行 init 方法</span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    _ &quot;net/http&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="分组定义"><a href="#分组定义" class="headerlink" title="分组定义"></a>分组定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 定义常量</span><br><span class="line">const (</span><br><span class="line">pi      = 3.1415926</span><br><span class="line">charset = &quot;UTF-8&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 变量</span><br><span class="line">var (</span><br><span class="line">index int</span><br><span class="line">count int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 结构体</span><br><span class="line">type (</span><br><span class="line">student struct &#123;</span><br><span class="line">name  string</span><br><span class="line">age   int</span><br><span class="line">grade string</span><br><span class="line">&#125;</span><br><span class="line">teacher struct &#123;</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">subject string</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="基础变量类型"><a href="#基础变量类型" class="headerlink" title="基础变量类型"></a>基础变量类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>不同类型的变量运算前需进行转换。</p><p>有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从-2^{n-1}到2^{n-1}-1。</p><p>无符号整数的所有bit位都用于表示非负数，值域是0到2^n-1。</p><ul><li>有符号<ul><li>int 长度取决于操作系统，32位操作系统是32位，64位操作系统是64位</li><li>rune 它是int32的别名，相当于<code>char</code>，<code>UTF-8</code>三字节，所以<code>rune</code>采用4字节兼容其他编码</li><li>int8</li><li>int16</li><li>int32</li><li>int64</li></ul></li><li>无符号<ul><li>uint</li><li>byte 等同于uint8</li><li>uint8</li><li>uint16</li><li>uint32</li><li>uint64</li><li>uintptr 没有指定具体的bit大小但是足以容纳指针。 具体大小根据操作系统改变。</li></ul></li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul><li>float32 最大值math.MaxFloat32，可以提供大约6个十进制数的精度</li><li>float64 最大值math.MaxFloat64，可以提供大约15个十进制数的精度</li></ul><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>Go语言提供了两种精度的复数类型：<code>complex64</code>和<code>complex128</code>，分别对应<code>float32</code>和<code>float64</code>两种浮点数精度。（实部和虚部分别是32位，64位）内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x complex128 = complex(1, 2) // 1+2i</span><br><span class="line">var y complex128 = complex(3, 4) // 3+4i</span><br><span class="line">fmt.Println(x*y)                 // &quot;(-5+10i)&quot;</span><br><span class="line">fmt.Println(real(x*y))           // &quot;-5&quot;</span><br><span class="line">fmt.Println(imag(x*y))           // &quot;10&quot;</span><br></pre></td></tr></table></figure><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>关键词 <code>bool</code> 用于定义 boolean类型变量，boolean 类型变量的取值只有 true 和 false, 零值(默认值)为 false<br>golang 不允许把 boolean 类型转变为数字类型</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量表达式的值在编译期计算，而不是在运行期。通过<code>const</code>声明。</p><p>在一个<code>const</code>声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。（类似java中的枚举）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">b = 1 &lt;&lt; (10 * iota)</span><br><span class="line">kb</span><br><span class="line">mb</span><br><span class="line">gb</span><br><span class="line">tb</span><br><span class="line">pb</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是不可改变的采用UTF8编码的Unicode码点（rune）序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello, world&quot;</span><br><span class="line">fmt.Println(len(s))     // &quot;12&quot;</span><br><span class="line">fmt.Println(s[0], s[2]) // &quot;104 108&quot; (&apos;h&apos; and &apos;l&apos;)</span><br><span class="line">c := s[len(s)]          // panic: runtime error: index out of range</span><br><span class="line">s[0] = &apos;L&apos;              // compile error: cannot assign to s[0]</span><br></pre></td></tr></table></figure><ul><li><code>bytes</code>包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的<code>[]byte</code>类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用<code>bytes.Buffer</code>类型将会更有效</li><li><code>strconv</code>包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换</li><li><code>unicode</code>包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。</li><li><code>strings</code>包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。</li><li>包变量一直常驻在内存到程序的结束，然后被系统垃圾回收器回收。也就是说包变量的生命周期是整个程序的执行时间。</li><li>局部变量，没有外部指针指向它，函数退出我们没有路径能访问到这个变量，这时它占用的存储空间就会被回收。</li></ul><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul><li>不需要括号</li><li>if条件里可以赋值</li><li>赋值的变量作用域就在这个if语句里</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func conditions(filename string) &#123;</span><br><span class="line">if file, err := os.Open(filename); err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(file)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li><code>switch</code>会自动<code>break</code>，除非使用<code>fallthrough</code></li><li><code>switch</code>的case不仅限于整数，可以是字符串、条件表达式等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func grade(score int) string &#123;</span><br><span class="line">g := &quot;&quot;</span><br><span class="line">switch &#123;</span><br><span class="line">case score &lt; 0 || score &gt; 100:</span><br><span class="line">panic(fmt.Sprintf(&quot;Wrong score: %d&quot;, score))</span><br><span class="line">case score &lt; 60:</span><br><span class="line">g = &quot;F&quot;</span><br><span class="line">case score &lt; 70:</span><br><span class="line">g = &quot;D&quot;</span><br><span class="line">case score &lt; 80:</span><br><span class="line">g = &quot;C&quot;</span><br><span class="line">case score &lt; 90:</span><br><span class="line">g = &quot;B&quot;</span><br><span class="line">case score &lt;= 100:</span><br><span class="line">g = &quot;A&quot;</span><br><span class="line">&#125;</span><br><span class="line">return g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>没有<code>while</code>，只能用<code>for</code>实现循环</li><li><code>for</code>条件里不需要括号</li><li>可以省略初始条件，结束条件，递增表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func binarySearch(num []int, target int) int &#123;</span><br><span class="line">if len(num) == 0 || num == nil &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start, end := 0, len(num)-1</span><br><span class="line">var mid int</span><br><span class="line"></span><br><span class="line">for start+1 &lt; end &#123;</span><br><span class="line">mid = start + (end-start)/2</span><br><span class="line">switch &#123;</span><br><span class="line">case num[mid] == target:</span><br><span class="line">// first end = mid; last start = mid; if any position, just return</span><br><span class="line">end = mid</span><br><span class="line">case num[mid] &lt; target:</span><br><span class="line">start = mid</span><br><span class="line">case num[mid] &gt; target:</span><br><span class="line">end = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if num[start] == target &#123;</span><br><span class="line">return start</span><br><span class="line">&#125; else if num[end] == target &#123;</span><br><span class="line">return end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建容器"><a href="#内建容器" class="headerlink" title="内建容器"></a>内建容器</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组是值类型，在函数中做参数时， 会拷贝整个数组</li><li>[10]int 和 [20]int是不同的类型</li><li>声明定义时必须指定大小，或者通过[…]int {}系统自动识别大小</li><li>go中一般不直接使用数组</li></ul><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><h4 id="Slice-概念"><a href="#Slice-概念" class="headerlink" title="Slice 概念"></a>Slice 概念</h4><ul><li>Slice 本身没有数据， 是对底层Array 的一个view</li><li>Slice 之上可以继续Slice， 这些slice都是对同一个Array的view</li><li>Slice 不可以向前扩展，但可以向后扩展；s[i]不可以超越len(s), 向后扩展不可以超过底层数组cap(s)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr := []int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;arr[2:6] = &quot;, arr[2:6]) // [2 3 4 5]</span><br><span class="line">fmt.Println(&quot;arr[:6] = &quot;, arr[:6])   // [0 1 2 3 4 5]</span><br><span class="line">fmt.Println(&quot;arr[2:] = &quot;, arr[2:])   // [2 3 4 5 6 7]</span><br><span class="line"></span><br><span class="line">// Extending slice</span><br><span class="line">s1 := arr[2:6]</span><br><span class="line">s2 := s1[3:5]</span><br><span class="line">// s1 = [2 3 4 5], len(s1) = 4, cap(s1) = 6</span><br><span class="line">fmt.Printf(&quot;s1 = %v, len(s1) = %d, cap(s1) = %d\n&quot;,</span><br><span class="line">s1, len(s1), cap(s1))</span><br><span class="line">// s2 = [5 6], len(s2) = 2, cap(s2) = 3</span><br><span class="line">fmt.Printf(&quot;s2 = %v, len(s2) = %d, cap(s2) = %d\n&quot;,</span><br><span class="line">s2, len(s2), cap(s2))</span><br><span class="line"></span><br><span class="line">fmt.Println(s1[5])   // index out of range</span><br><span class="line">fmt.Println(s1[3:7]) // slice bounds out of range</span><br></pre></td></tr></table></figure><h4 id="Slice-操作"><a href="#Slice-操作" class="headerlink" title="Slice 操作"></a>Slice 操作</h4><ul><li>添加元素如果超过cap, 系统会新分配一个更大的底层数组</li><li>由于值传递的关系， 必须接收 <code>append</code>的返回值, 即 <code>s = append(s, val)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var s []int // s == nil</span><br><span class="line"></span><br><span class="line">// cap 空间不够时，每次增加一倍</span><br><span class="line">for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">printSlice(s)</span><br><span class="line">s = append(s, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 := []int&#123;2, 4, 6, 8&#125;</span><br><span class="line">printSlice(s1)</span><br><span class="line"></span><br><span class="line">// 指定slice初始大小</span><br><span class="line">s2 := make([]int, 16)</span><br><span class="line">s3 := make([]int, 10, 32)</span><br><span class="line"></span><br><span class="line">printSlice(s2)</span><br><span class="line">printSlice(s3)</span><br><span class="line"></span><br><span class="line">// Copying slice</span><br><span class="line">copy(s2, s1)</span><br><span class="line">printSlice(s2)</span><br><span class="line"></span><br><span class="line">// Deleting elements from slice</span><br><span class="line">s2 = append(s2[:3], s2[4:]...)</span><br><span class="line">printSlice(s2)</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>在Go语言中，一个map就是一个哈希表的引用，所以map的key是无序的</li><li>map类型可以写为map[K]V，其中K对应的key必须是支持==比较运算符的数据类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func maxLenOfNoRepeatingStr(s string) int &#123;</span><br><span class="line">lastOccurred := make(map[rune]int)</span><br><span class="line"></span><br><span class="line">start := 0</span><br><span class="line">maxLen := 0</span><br><span class="line"></span><br><span class="line">for i, ch := range []rune(s) &#123;</span><br><span class="line">lastI, ok := lastOccurred[ch]</span><br><span class="line">if ok &amp;&amp; lastI &gt; start &#123;</span><br><span class="line">start = lastI + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if i-start+1 &gt; maxLen &#123;</span><br><span class="line">maxLen = i - start + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastOccurred[ch] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;h3 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h3&gt;&lt;p&gt;命名规则同其他语言一样，以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。其中大写字母开头的，可以被其他包访问(相当于&lt;code&gt;public&lt;/code&gt;)；否则只能在包内使用(相当于&lt;code&gt;private&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;常量、变量、类型、接口、结构、函数等的名称命名规则均一样。&lt;/p&gt;
&lt;h3 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h3&gt;&lt;p&gt;按照Go语言规范，任何类型在未初始化时都对应一个零值：布尔类型是false，整型是0，字符串是””，而指针，函数，interface，slice，channel和map的零值都是nil。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var str string // str == &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var i int      // i == 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var f float64  // f == 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var p *int     // p == nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s := &amp;quot;hello&amp;quot;   // 只能在函数或者方法内&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2 := new(int) // p2, *int 类型, 指向匿名的 int 变量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="http://blog.lichfaker.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>gitbook使用</title>
    <link href="http://blog.lichfaker.com/2018/01/16/gitbook%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lichfaker.com/2018/01/16/gitbook使用/</id>
    <published>2018-01-16T20:14:09.000Z</published>
    <updated>2018-08-26T05:43:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitbook踩坑记"><a href="#gitbook踩坑记" class="headerlink" title="gitbook踩坑记"></a>gitbook踩坑记</h2><h3 id="Easy的开始"><a href="#Easy的开始" class="headerlink" title="Easy的开始"></a>Easy的开始</h3><p>今天在<code>Gitbook</code>上看中了一本《GO语言圣经》，由于在线看速度比较慢不太方便，于是便想下载源码自行编译查看学习。</p><p>操作步骤也比较的简单：</p><ol><li><p>安装Node环境</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 详情参考 https://nodejs.org/en/download/package-manager/</span><br><span class="line"># brew 安装</span><br><span class="line">brew install node</span><br><span class="line"># 或者通过nvm管理</span><br><span class="line">nvm install node</span><br></pre></td></tr></table></figure></li><li><p>安装gitbook-cli</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gitbook-cli</span><br><span class="line"># or cnpm</span><br><span class="line">cnpm install -g gitbook-cli</span><br></pre></td></tr></table></figure></li><li><p>进入gitbook目录文件夹，依次执行<code>gitbook install</code>，<code>gitbook build</code></p></li></ol><h3 id="一堆错误"><a href="#一堆错误" class="headerlink" title="一堆错误"></a>一堆错误</h3><p>由于<code>Node</code>环境之前一直都有，版本是<code>v8.3.0</code>，所以我直接执行了第二步，成功安装了<code>gitbook-cli</code></p><h4 id="Cannot-find-module-‘internal-fs’"><a href="#Cannot-find-module-‘internal-fs’" class="headerlink" title="Cannot find module ‘internal/fs’"></a>Cannot find module ‘internal/fs’</h4><p>执行<code>gitbook install</code>后，提示在安装<code>2.6.7</code>版本，然后输出了一堆信息，但是最后安装失败了，错误如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Error: Cannot find module &apos;internal/fs&apos;</span><br><span class="line"> at Function.Module._resolveFilename (module.js:485:15)</span><br><span class="line"> at Function.Module._load (module.js:437:25)</span><br><span class="line"> at Module.require (module.js:513:17)</span><br><span class="line"> at require (internal/module.js:11:18)</span><br><span class="line"> at evalmachine.&lt;anonymous&gt;:40:20</span><br><span class="line"> at Object.&lt;anonymous&gt; (..../graceful-fs/fs.js:11:1)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p><p>有了明确的错误，就直接<code>Google</code>了，<a href="https://github.com/nodejs/node/issues/13361" target="_blank" rel="noopener">查看Issue</a>很多都说重新安装就好了，我也不清楚到底怎么回事，好像之前OSX有升级过，可能部分库受到了影响吧，所以还是老老实实的重装了。</p><h4 id="Cannot-find-module-‘internal-util-types’"><a href="#Cannot-find-module-‘internal-util-types’" class="headerlink" title="Cannot find module ‘internal/util/types’"></a>Cannot find module ‘internal/util/types’</h4><p>重装<code>Node</code>后，还是出现了错误，（没仔细看，印象中好像一样），第一反应是有缓存， 于是把<code>.gitbook</code>目录删除了，再次安装，出现新的错误如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error loading version latest: Error: Cannot find module &apos;internal/util/types&apos;</span><br><span class="line">at Function.Module._resolveFilename (module.js:555:15)</span><br><span class="line">at Function.Module._load (module.js:482:25)</span><br><span class="line">at Module.require (module.js:604:17)</span><br><span class="line">at require (internal/module.js:11:18)</span><br><span class="line">at evalmachine.&lt;anonymous&gt;:31:26</span><br><span class="line">at Object.&lt;anonymous&gt; (/Users/lichfaker/.gitbook/versions/2.6.7/node_modules/graceful-fs/fs.js:11:1)</span><br><span class="line">at Module._compile (module.js:660:30)</span><br><span class="line">at Object.Module._extensions..js (module.js:671:10)</span><br><span class="line">at Module.load (module.js:573:32)</span><br><span class="line">at tryModuleLoad (module.js:513:12)</span><br></pre></td></tr></table></figure></p><blockquote><p>针对这个问题主要是<code>graceful-fs</code>跟<code>node</code>的版本不兼容导致的，要么将<code>node</code>降级到6以下，要么升级<code>graceful-fs</code></p></blockquote><p>怎么可能这么坑呢？抱着试一试的态度，我尝试查看获取最新版的<code>gitbook</code>，一顿命令操作发现，最新稳定的版本是<code>3.2.3</code>，而每次执行<code>gitbook install</code> 默认安装的版本是<code>2.6.7</code>。正常来说不可能放着最新的版本不用而使用较旧的版本，除非是哪个地方指定了具体使用的版本。</p><p>最后在书的源码目录下面的<code>book.json</code>中找到了罪魁祸首,将其版本改成<code>3.2.3</code>成功解决问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;gitbook&quot;: &quot;2.x&quot;,</span><br><span class="line">&quot;title&quot;: &quot;Go语言圣经&quot;,</span><br><span class="line">&quot;description&quot;: &quot;&lt;The Go Programming Language&gt;中文版&quot;,</span><br><span class="line">&quot;language&quot;: &quot;zh-hans&quot;,</span><br><span class="line">&quot;structure&quot;: &#123;</span><br><span class="line">&quot;readme&quot;: &quot;preface.md&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;plugins&quot;: [</span><br><span class="line">&quot;katex&quot;,</span><br><span class="line">&quot;-search&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gitbook-使用"><a href="#Gitbook-使用" class="headerlink" title="Gitbook 使用"></a>Gitbook 使用</h2><p>安装这个东西，折腾了近2个小时，中间还走过一些弯路，再小再简单的东西，如果不去了解就盲目的使用，也可能会引发一些意想不到的问题，所以决定好好的了解下<code>gitbook</code></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ul><li>使用 <code>gitbook init</code> 初始化书籍目录</li><li>使用 <code>gitbook build</code> 编译书籍</li><li>使用 <code>gitbook serve</code> 编译并预览书籍</li><li>使用 <code>gitbook pdf</code> 导出pdf，需要依赖 <code>ebook-convert</code> (同 <code>mobi</code> , <code>epub</code> )</li></ul><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>书本的第一页内容是从文件 <code>README.md</code> 中提取的。如果这个文件名没有出现在 <code>SUMMARY</code> 中，那么它会被添加为章节的第一个条目，文件 <code>SUMMARY.md</code> 来定义书本的章节和子章节的结构。</p><p>GitBook会读取 <code>.gitignore</code>，<code>.bookignore</code>，<code>.ignore</code> 文件来获取忽略的文件和目录的列表。<br>这些文件的格式，遵循和 <code>.gitignore</code> 同样的约定</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>所有的配置都以JSON格式存储在名为 <code>book.json</code> 的文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    // gitbook 版本</span><br><span class="line">    &quot;gitbook&quot;: &quot;&gt;=3.0.0&quot;,</span><br><span class="line"></span><br><span class="line">    // 作者</span><br><span class="line">    &quot;author&quot;: &quot;LichFaker&quot;, </span><br><span class="line"></span><br><span class="line">    // 图书标题和描述 (默认从README抽取)</span><br><span class="line">    &quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;测试一下&quot;,</span><br><span class="line"></span><br><span class="line">    // 产生的书籍的类型</span><br><span class="line">    // 注意: 它会覆盖命令行传入的参数</span><br><span class="line">    // 不建议在此文件中配置</span><br><span class="line">    &quot;generator&quot;: &quot;site&quot;, </span><br><span class="line"></span><br><span class="line">    // 指定语言为中文</span><br><span class="line">    &quot;language&quot;: &quot;zh-hans&quot;, </span><br><span class="line"></span><br><span class="line">    // 输出文件夹</span><br><span class="line">    // 注意: 它会覆盖命令行传入的参数</span><br><span class="line">    // 不建议在此文件中配置</span><br><span class="line">    &quot;output&quot;: null,</span><br><span class="line"></span><br><span class="line">    // 模版中的链接 (null: default, false: remove, string: new value)</span><br><span class="line">    &quot;links&quot;: &#123;</span><br><span class="line">    // Custom links at top of sidebar</span><br><span class="line">    &quot;sidebar&quot;: &#123;</span><br><span class="line">        &quot;Custom link name&quot;: &quot;https://customlink.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">        // Sharing links</span><br><span class="line">        &quot;sharing&quot;: &#123;</span><br><span class="line">            &quot;google&quot;: null,</span><br><span class="line">            &quot;facebook&quot;: null,</span><br><span class="line">            &quot;twitter&quot;: null,</span><br><span class="line">            &quot;weibo&quot;: null,</span><br><span class="line">            &quot;all&quot;: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // PDF 参数</span><br><span class="line">    &quot;pdf&quot;: &#123;</span><br><span class="line">        // Add toc at the end of the file</span><br><span class="line">        &quot;toc&quot;: true,</span><br><span class="line">        // Add page numbers to the bottom of every page</span><br><span class="line">        &quot;pageNumbers&quot;: false,</span><br><span class="line">        // Font size for the fiel content</span><br><span class="line">        &quot;fontSize&quot;: 12,</span><br><span class="line">        // Paper size for the pdf</span><br><span class="line">        // Choices are [u’a0’, u’a1’, u’a2’, u’a3’, u’a4’, u’a5’, u’a6’, u’b0’, u’b1’, u’b2’, u’b3’, u’b4’, u’b5’, u’b6’, u’legal’, u’letter’]</span><br><span class="line">        &quot;paperSize&quot;: &quot;a4&quot;,</span><br><span class="line">        // Margin (in pts)</span><br><span class="line">        // Note: 72 pts equals 1 inch</span><br><span class="line">        &quot;margin&quot;: &#123;</span><br><span class="line">            &quot;right&quot;: 62,</span><br><span class="line">            &quot;left&quot;: 62,</span><br><span class="line">            &quot;top&quot;: 36,</span><br><span class="line">            &quot;bottom&quot;: 36</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;disqus&quot;,</span><br><span class="line">        &quot;theme-gestalt&quot;, </span><br><span class="line">        &quot;-theme-default&quot;, </span><br><span class="line">        &quot;styles-sass-fix&quot;, </span><br><span class="line">        &quot;multipart&quot;, </span><br><span class="line">        &quot;toggle-chapters&quot;</span><br><span class="line">    ], </span><br><span class="line">    &quot;pluginsConfig&quot;: &#123;</span><br><span class="line">        &quot;theme-gestalt&quot;: &#123;</span><br><span class="line">            &quot;logo&quot;: &quot;/core-scrapy/assets/logo.png&quot;, </span><br><span class="line">            &quot;favicon&quot;: &quot;/core-scrapy/assets/favicon.png&quot;, </span><br><span class="line">            &quot;excludeDefaultStyles&quot;: true</span><br><span class="line">        &#125;, </span><br><span class="line">        &quot;disqus&quot;: &#123;</span><br><span class="line">            &quot;shortName&quot;: &quot;yidao620cgithubio&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    // 自定义样式</span><br><span class="line">    &quot;styles&quot;: &#123;</span><br><span class="line">        &quot;website&quot;: &quot;./styles/website.scss&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;variables&quot;: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://toolchain.gitbook.com/" target="_blank" rel="noopener">https://toolchain.gitbook.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gitbook踩坑记&quot;&gt;&lt;a href=&quot;#gitbook踩坑记&quot; class=&quot;headerlink&quot; title=&quot;gitbook踩坑记&quot;&gt;&lt;/a&gt;gitbook踩坑记&lt;/h2&gt;&lt;h3 id=&quot;Easy的开始&quot;&gt;&lt;a href=&quot;#Easy的开始&quot; class=&quot;headerlink&quot; title=&quot;Easy的开始&quot;&gt;&lt;/a&gt;Easy的开始&lt;/h3&gt;&lt;p&gt;今天在&lt;code&gt;Gitbook&lt;/code&gt;上看中了一本《GO语言圣经》，由于在线看速度比较慢不太方便，于是便想下载源码自行编译查看学习。&lt;/p&gt;
&lt;p&gt;操作步骤也比较的简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Node环境&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gitbook" scheme="http://blog.lichfaker.com/tags/Gitbook/"/>
    
      <category term="Node" scheme="http://blog.lichfaker.com/tags/Node/"/>
    
  </entry>
  
</feed>
